=pod

=encoding utf8

=head1 Os plugins do Catalyst

O L<Catalyst::Manual::ExtendingCatalyst>, seE<ccedil>E<atilde>o "BEST
PRACTICES" afirma categoricamente:

"NE<atilde>o crie um plugin a nE<atilde>o ser que seja realmente
necessE<aacute>rio."

Um plugin deve ser cuidadoso jE<aacute> que ele mexe com o nE<uacute>cleo do
Catalyst. Se o seu nE<atilde>o precisa necessariamente lidar com isso,
considere fazer um Controller ou Model base. Ainda assim, se vocE<ecirc>
realmente acha necessE<aacute>rio, considere antes utilizar o Moose::Role.

Vamos entender como os plugins funcionam para entender a
afirmaE<ccedil>E<atilde>o e saber quando usE<aacute>-los.

Ao criar um plugin, todo mE<eacute>todo implementado, importado ou sobrescrito
estarE<aacute> disponE<iacute>vel na aplicaE<ccedil>E<atilde>o poluindo
completamente o namespace global. Somente casos onde as coisas precisam estar
globalmente disponE<iacute>veis ou que precisam estar intimamente ligados ao
ciclo da requisiE<ccedil>E<atilde>o, como sessE<otilde>es e
autenticaE<ccedil>E<atilde>o, sE<atilde>o candidatos a um plugin.

A implementaE<ccedil>E<atilde>o E<eacute> muito simples. Seu plugin
serE<aacute> inserido no topo da heranE<ccedil>a da sua
aplicaE<ccedil>E<atilde>o, acima do Catalyst inclusive. Com isso vocE<ecirc>
pode alterar o ciclo de vida de uma requisiE<ccedil>E<atilde>o.

O exemplo a seguir sobrescreve o mE<eacute>todo C<uri_for> para que ele emita
um aviso toda a vez que for chamado sem um objeto Action como primeiro
parE<acirc>metro. O nome da classe E<eacute> propositadamente simples:

	package Catalyst::Plugin::UriforUndefWarning;
	use strict;
	use Scalar::Util qw/blessed/;
	use MRO::Compat;

	sub uri_for {
   		my $c = shift;
		my $uri = $c->next::method(@_);
		$c->log->warn('uri_for with non action: ', join(',',@_))
		if (!blessed($_[0]) || !$_[0]->isa('Catalyst::Action'));
		return $uri;
	}

	1;

Como citado acima, sempre antes de criar um plugin, considere outras
possibilidades. Este exemplo pode ser facilmente (e de forma mais apropriada)
implementado com L<Moose::Role>:

	package CatalystX::UriforUndefWarning;
	use Moose::Role;
	use namespace::autoclean;

	after 'uri_for' => sub {
		my ($c, $arg) = @_;
		$c->log->warn( 'uri_for with non action: ', join(', ', @_), )
		if (!blessed($_[0]) || !$_[0]->isa('Catalyst::Action'));
		return $uri;
	}

	1;

Observe que o Catalyst carregara qualquer Moose Role na lista de plugins, e
ira aplicar elas na sua aplicaE<ccedil>E<atilde>o.

=head2 InstalaE<ccedil>E<atilde>o

Os plugins do Catalyst sE<atilde>o disponibilizados via B<CPAN> e sua
instalaE<ccedil>E<atilde>o E<eacute> simplificado pelo uso do
utilitE<aacute>rio C<cpan>. Utilizando o plugin Catalyst::Plugin::Session,
farE<iacute>amos:

	cpan Catalyst::Plugin::Session

Para maiores detalhes de como usar o CPAN, consulte o
L<http://www.perl.org.br/Artigos/ArtigoDanielMantovani2009x12x02> tutorial
criado pelo Daniel Mantovani.

=head2 ConfiguraE<ccedil>E<atilde>o

Quando vocE<ecirc> inicia um projeto Catalyst utilizando os
utilitE<aacute>rios de linha de comando vocE<ecirc> terE<aacute> algo como
(supondo uma aplicaE<ccedil>E<atilde>o chamada C<MyApp>) C<MyApp/lib/MyApp.pm>
alE<eacute>m dos demais diretE<oacute>rios e arquivos resultantes. Neste
MyApp.pm E<eacute> que vocE<ecirc> dirE<aacute> para sua
aplicaE<ccedil>E<atilde>o quais plugins usar e tambE<eacute>m ira configurar o
comportamento deles. Usando o Catalyst::Plugin::Session como exemplo
novamente, edite o MyApp.pm e carregue o plugin da seguinte maneira:

	use Catalyst qw/
                Session
                Session::Store::FastMap
                Session::State::Cookie
               /;

Com isso vocE<ecirc> terE<aacute> o esquema de sessE<otilde>es funcionando.
Para maiores detalhes consulte a documentaE<ccedil>E<atilde>o do plugin. Ainda
no MyApp.pm, vamos configurar o parE<acirc>metro C<expires>:

	__PACKAGE__->config(
    		'Plugin::Session' => {
        	expires => 3600
   	 }
	);

=head1 AUTOR

Giuliani D. Sanches. <giulianisanches@gmail.com>

=cut

1;


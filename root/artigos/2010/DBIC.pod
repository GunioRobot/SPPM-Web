=head1 BANCOS DE DADOS RELACIONAIS, ORIENTAÃÃO A OBJETOS E DBIx::Class

    "Mostre-me seus fluxogramas, esconda suas tabelas e eu continuarei
     mistificado. Mostre-me suas tabelas e nÃ£o precisarei dos seus fluxogramas,
     eles serÃ£o Ã³bvios"
     -- Frederick Brooks - The Mythical Man-Month

    "Entregar o produto Ã© um dos requisitos"
    -- http://www.jamesonwatts.com/2009/09/28/shipping-is-a-feature/

Bancos de dados relacionais tem sido a norma no desenvolvimento de aplicaÃ§Ãµes
de todos os tamanhos e tipos de complexidade a cerca de 30 anos. A combinaÃ§Ã£o
de um modelo com forte base cientÃ­fica e a vasta disponibilidade de literatura
e ferramentas fazem com que as bases relacionais sejam uma escolha sÃ³lida para
a maioria das aplicaÃ§Ãµes em desenvolvimento.
O paradigma de programaÃ§Ã£o orientado a objetos, Ã© relativamente bem menos
popular e formal, mas tambÃ©m vastamente utilizado dentro do seu campo de
aplicaÃ§Ã£o. Pensar em termos de objetos e das interaÃ§Ãµes entre eles Ã© uma
tendÃªncia natural para um ser humano e estabelece uma ponte entre a engenharia
tradicional e o desenvolvimento de software.
Bancos de dados relacionais e orientaÃ§Ã£o a objetos sÃ£o elementos da engenharia
de software que vem sendo utilizados em conjunto por muito tempo. Esse artigo
irÃ¡ abordar as vantagens, desvantagens e apresentar o uso do DBIx::Class como
soluÃ§Ã£o para os problemas cotidianos dessa parceria tecnolÃ³gica.

=head2 A DIFERENÃA DE IMPEDÃNCIA

Objetos e RelaÃ§Ãµes sÃ£o conceitos de natureza fundamentalmente diferentes,
apesar de apresentarem algumas similaridades deceptivas. A travessia entre
objetos ocorre atravÃ©s de ponteiros e referÃªncias enquanto as relaÃ§Ãµes sÃ£o
unidas atravÃ©s de produtos cartesianos e chaves estrangeiras, o que leva a
soluÃ§Ãµes de otimizaÃ§Ã£o diferentes para ambos os casos. As operaÃ§Ãµes de acesso
tambÃ©m variam bastante a depender do volume de dados e relacionamentos
envolvidos. Por exemplo, obter um Ãºnico estudante dentre todos os estudantes
de um determinado estado Ã© uma operaÃ§Ã£o diferente de obter o estudante com o
melhor desempenho escolar. A implementaÃ§Ã£o orientada a objeto presume que a
informaÃ§Ã£o Ã© acessÃ­vel de maneira uniforme. TambÃ©m vale ressaltar que, ao
contrÃ¡rio de registros em uma relaÃ§Ã£o, objetos nÃ£o sÃ£o canÃ´nicos.

=head2 O PROBLEMA DA REFATORAÃÃO

Durante o ciclo de vida de um projeto de software, ocorrem mudanÃ§as
significativas em todas as camadas. Manter a integraÃ§Ã£o entre os componentes
de software Ã© uma tarefa Ã¡rdua e contÃ­nua. Uma simples mudanÃ§a no nome de um
campo requer que todas as referÃªncias ao nome desse campo sejam atualizadas na
aplicaÃ§Ã£o. Uma refatoraÃ§Ã£o tÃ­pica envolve muito mais do que renomear um campo,
tabelas sÃ£o criadas e removidas, chaves sÃ£o alteradas para refletir as mudanÃ§as,
e dados que antes viviam num Ãºnico registro agora se encontram renormalizados
entre vÃ¡rias tabelas e registros e todo o cÃ³digo da aplicaÃ§Ã£o agora precisa ser
atualizado para refletir as mudanÃ§as estruturais.

=head2 PADRÃES DE ACESSO A DADOS

Ao longo dos anos, a principal tÃ©cnica desenvolvida para atenuar os problemas
com o acesso a dados Ã© o encapsulamento da complexidade numa camada dedicada.
Tipicamente, ela atua como embaixatriz entre o domÃ­nio da base de dados e o da
aplicaÃ§Ã£o e se ajusta para que alteraÃ§Ãµes em qualquer um dos lados nÃ£o impactue
(muito) o outro.

=head3 Data Access Object

Dentro do paradigma orientado a objetos, representar a camada de acesso a dados
com um objeto que Ã© responsÃ¡vel por consultar a base de dados e construir
outros objetos a partir dos resultados Ã© uma soluÃ§Ã£o bastante Ã³bvia e direta.
Suponha um caso simples: construir boletins de alunos de ensino fundamental.

=begin pod:xhtml

<p align="center"><img src="http://sao-paulo.pm.org/static/images/equinocio/2010/mar/dbic/Naive-Schema.png" alt="Naive Schema" /></p>

=end pod:xhtml

Primeiro, criamos o schema

    CREATE TABLE nota (
        estudante VARCHAR(255) NOT NULL,
        materia VARCHAR(255) NOT NULL,
        nota INT NOT NULL,
        PRIMARY KEY (estudante, materia)
    );

Populamos com alguns valores de teste:

    INSERT INTO nota (estudante, materia, valor) VALUES ('JoÃ£o',  'Biologia', 8);
    INSERT INTO nota (estudante, materia, valor) VALUES ('JoÃ£o',  'MatemÃ¡tica', 7);
    INSERT INTO nota (estudante, materia, valor) VALUES ('JoÃ£o',  'FÃ­sica', 6);
    INSERT INTO nota (estudante, materia, valor) VALUES ('Maria', 'Biologia', 9);

Depois, um Data Access Object simples:

    package DAO;
    use Moose;
    use DBI;

    use Estudante;
    use Materia;

    has info_conexao => (
        isa => 'ArrayRef',
        is => 'ro',
        auto_deref => 1,
        required => 1
    );
    has _dbh => (isa => 'DBI::db', is => 'ro', lazy_build => 1);

    sub _build__dbh { DBI->connect(shift->info_conexao) }

    sub buscar_estudante {
        my($self, $nome_estudante) = @_;
        my $sth = $self->_dbh->prepare(<<SQL);
    SELECT materia, valor FROM nota WHERE estudante = ?
    SQL

        $sth->execute($nome_estudante);
        my $result = $sth->fetchall_arrayref;
        return unless @$result;

        my $estudante = Estudante->new(nome => $nome_estudante, materias => []);
        my @materias = map {
            Materia->new(
                estudante => $estudante,
                nome => $_->[0], # campo: materia
                nota => $_->[1]) # campo: valor
        } @$result;

        push @{$estudante->materias}, @materias;

        return $estudante;
    }

    1;

E agora, as classes do lado da aplicaÃ§Ã£o:

    package Estudante;
    use Moose;

    has nome     => (isa => 'Str', is => 'ro', required => 1);
    has materias => (isa => 'ArrayRef', is => 'ro', required => 1);

    1;

    package Materia;
    use Moose;

    has estudante => (isa => 'Estudante', is => 'ro', required => 1);
    has nome => (isa => 'Str', is => 'ro', required => 1);
    has nota => (isa => 'Int', is => 'ro', required => 1);

    sub foi_aprovado { shift->nota >= 7 }

    1;

E finalmente, nosso teste:

    use warnings;
    use strict;

    use Test::More qw(no_plan);

    use DAO;

    my $dao = DAO->new(
        info_conexao => ['dbi:Pg:dbname=equinocio_students', 'edenc', '']
    );

    my $nome = 'JoÃ£o';
    isa_ok(my $estudante = $dao->buscar_estudante($nome), 'Estudante');
    cmp_ok(scalar @{$estudante->materias}, '==', 3);
    isa_ok($_, 'Materia') for @{$estudante->materias};
    is($estudante->nome, $nome);

    my %nota_esperada = (Biologia => 8, 'MatemÃ¡tica' => 7, 'FÃ­sica' => 6);
    cmp_ok(
        $_->nota, '==', $nota_esperada{$_->nome},
        $_->nome . ' nota'
    ) for @{$estudante->materias};

    my %aprovacao_esperada = (Biologia => 1, 'MatemÃ¡tica' => 1, 'FÃ­sica' => 0);

    cmp_ok(
        $_->foi_aprovado, '==', $aprovacao_esperada{$_->nome},
        $_->nome . ' aprovaÃ§Ã£o'
    ) for @{$estudante->materias};

Rodamos o teste, e conferimos que estÃ¡ tudo ok:

    prove -lv t/001-buscar-estudante.t
    t/001-buscar-estudante.t ..
    ok 1 - The object isa Estudante
    ok 2
    ok 3 - The object isa Materia
    ok 4 - The object isa Materia
    ok 5 - The object isa Materia
    ok 6
    ok 7 - Biologia nota
    ok 8 - FÃ­sica nota
    ok 9 - MatemÃ¡tica nota
    ok 10 - Biologia aprovaÃ§Ã£o
    ok 11 - FÃ­sica aprovaÃ§Ã£o
    ok 12 - MatemÃ¡tica aprovaÃ§Ã£o
    1..12
    ok
    All tests successful.
    Files=1, Tests=12,  1 wallclock secs ( 0.03 usr  0.02 sys +  0.25 cusr  0.03 csys =  0.33 CPU)
    Result: PASS

O bom observador vai perceber algumas limitaÃ§Ãµes nessa abordagem. Por exemplo,
esse DAO nÃ£o sabe criar nem atualizar objetos, dentre outras. Outra questÃ£o
notÃ¡vel Ã© falta de normalizaÃ§Ã£o na tabela, afinal de contas, Ã© uma
implementaÃ§Ã£o ingÃªnua. Suponha tambÃ©m que surgiu um requisito de Ãºltima hora:
os estudantes precisam ser agrupados em turmas, ser listados em ordem
alfabÃ©tica e as notas de um determinado estudante precisam estar ordenadas por
matÃ©ria. Uma abordagem mais correta seria:

=begin pod:xhtml

<p align="center"><img src="http://sao-paulo.pm.org/static/images/equinocio/2010/mar/dbic/Normalized-Schema.png" alt="Normalized Schema" /></p>

=end pod:xhtml

Um pouco de anÃ¡lise vai revelar que a API do DAO precisa ser repensada. Por
exemplo, um mÃ©todo para realizar a listagem dos estudantes seria bastante
similar ao mÃ©todo que obtÃ©m um estudante individual, basta omitir a restriÃ§Ã£o
por nome. Outra porÃ§Ã£o de cÃ³digo que pode ser reaproveitada Ã© a construÃ§Ã£o do
objetos Estudante e MatÃ©ria. Vale ressaltar que operaÃ§Ãµes como ordenaÃ§Ã£o e
agrupamento sÃ£o mais eficientes se realizadas pelo prÃ³prio backend de storage.
Se, por exemplo, for necessÃ¡rio exibir os 10 alunos com as melhores notas no
paÃ­s inteiro, fazer a ordenaÃ§Ã£o no lado da aplicaÃ§Ã£o geraria um overhead de
memÃ³ria proibitivo. A API do DAO tambÃ©m precisa ser cuidadosamente
confeccionada para evitar a falÃ¡cia comum de:

    $dao->listar_estudantes
    $dao->listar_estudantes_ordenados_por_nome
    $dao->listar_estudantes_ordenados_por_nota
    # etc...

O problema com essa abordagem Ã© que quando for necessÃ¡rio ordenar estudantes
por nome e nota, nÃ£o vai ser possÃ­vel reaproveitar os mÃ©todos existentes. Esse
padrÃ£o de consultas combinadas Ã© bastante recorrente durante a vida de uma
aplicaÃ§Ã£o. Fica claro que o principal problema na construÃ§Ã£o de um DAO Ã©
projetar uma arquitetura e API que chegue a um ponto de convergÃªncia Ãºtil para
a aplicaÃ§Ã£o, mesmo porque, se a API muda constantemente, a camada de acesso
serÃ¡ inÃºtil porque a aplicaÃ§Ã£o terÃ¡ que mudar tambÃ©m, para acomodar as
mudanÃ§as na API. O mais correto em termos de contrato seria o DAO expor mÃ©todos
que tenham sentido conceitual para a aplicaÃ§Ã£o, por exemplo:

    $dao->melhores_estudantes_nacionais
    $dao->estudantes_aprovados
    $dao->estudantes_por_serie('7Âª SÃ©rie')
    # etc...

Dessa forma, os detalhes de implementaÃ§Ã£o sÃ£o encapsulados e a aplicaÃ§Ã£o se
preocupa apenas com as regras de negÃ³cio. AlÃ©m disso, o observador muito
cauteloso tambÃ©m irÃ¡ perceber que nÃ£o existe tratamento de erros a nÃ­vel de
infra-estrutura, como verificaÃ§Ã£o de persistÃªncia da conexÃ£o com o banco de
dados, pooling de conexÃµes e relatÃ³rio de erros.

=head3 MAPEAMENTO OBJETO-RELACIONAL

O mapeamento objeto-relacional (popularmente conhecido como ORM -
Object-Relational Mapping/Mapper) Ã© uma tentativa de reaproveitar trabalho
baseado nas similaridades entre os modelos orientado a objetos e relacional.
Nem todas as soluÃ§Ãµes sÃ£o felizes, e a maioria trazem mais problemas do que
soluÃ§Ãµes. Muitos ORMs sÃ£o baseados em convenÃ§Ãµes, ou seja, requerem que a
modelagem e arquitetura da base de dados seja adequada ao caso para o qual o
ORM foi projetado. Outros introspectam e refletem os campos das tabelas
diretamente para atributos de objetos, o que significa que mÃ©todos de acesso
para os atributos modificados magicamente deixam de funcionar em toda a
aplicaÃ§Ã£o. A maioria das convenÃ§Ãµes nÃ£o permitem o uso de chaves compostas, o
que reduz bastante a utilidade de ORMs em sistemas mais complexos. Muitos
tambÃ©m substituem SQL por uma linguagem de mapeamento prÃ³pria, o que adiciona
um elemento de complexidade extra ao cÃ³digo. Em particular, DBA's que jÃ¡ sÃ£o
bastante proficientes com SQL se sentem menos confortÃ¡veis e sÃ£o menos
produtivos aprendendo uma linguagem especÃ­fica e que tipicamente Ã© menos
flexÃ­vel do que SQL. A arquitetura baseada em convenÃ§Ã£o tambÃ©m reduz a
extensibilidade e customizaÃ§Ã£o dos sistemas, criando barreiras na hora de se
realizarem otimizaÃ§Ãµes especÃ­ficas de domÃ­nio. Todos esses problemas tem criado
uma certa aversÃ£o a ORMs entre os DBA's mais experientes.

=head2 DBIx::Class TO THE RESCUE

Pensando em todos os problemas previamente mencionados, o DBIx::Class tenta
adotar uma abordagem diferenciada. A principal regra Ã© manter a flexibilidade
provendo defaults sensatos. Os defaults permitem que as aplicaÃ§Ãµes comecem a
ser desenvolvidas rapidamente e as customizaÃ§Ãµes podem ser acrescentadas ao
longo do projeto. Pode-se dizer que o DBIx::Class estÃ¡ mais para um framework
para projetos de DAO do que um ORM. InvÃ©s de mapear diretamente para classes
da aplicaÃ§Ã£o, sÃ£o construidos objetos intermediÃ¡rios que facilitam a construÃ§Ã£o
de objetos do domÃ­nio. Um sistema de meta-dados "ensina" esses objetos a
interagirem com as tabelas, de acordo com o backend adotado.

=head3 Conceitos do DBIx::Class

=head4 Schema

Objetos Schema sÃ£o o ponto de entrada para a camada de acesso a dados. A
construÃ§Ã£o da classe Ã© bem simples e direta:

    package MySchema;
    use warnings;
    use strict;
    use base qw/DBIx::Class::Schema/;

    __PACKAGE__->load_namespaces;

    1;

O mÃ©todo C<load_namespaces> indica que queremos carregar as definiÃ§Ãµes de
tabelas do local padrÃ£o que sÃ£o os namespaces C<MySchema::Result> e
C<MySchema::ResultSet>. Essas definiÃ§Ãµes podem ser escritas manualmente ou
introspectadas de uma base existente atravÃ©s do C<DBIx::Class::Schema::Loader>.
Suponha o seguinte schema:

    --
    -- PostgreSQL database dump
    --

    SET client_encoding = 'UTF8';
    SET standard_conforming_strings = off;
    SET check_function_bodies = false;
    SET client_min_messages = warning;
    SET escape_string_warning = off;

    SET search_path = public, pg_catalog;

    --
    -- Name: aluno_id_seq; Type: SEQUENCE; Schema: public; Owner: edenc
    --

    CREATE SEQUENCE aluno_id_seq
        INCREMENT BY 1
        NO MAXVALUE
        NO MINVALUE
        CACHE 1;


    ALTER TABLE public.aluno_id_seq OWNER TO edenc;

    --
    -- Name: aluno_id_seq; Type: SEQUENCE SET; Schema: public; Owner: edenc
    --

    SELECT pg_catalog.setval('aluno_id_seq', 2, true);


    SET default_tablespace = '';

    SET default_with_oids = false;

    --
    -- Name: aluno; Type: TABLE; Schema: public; Owner: edenc; Tablespace:
    --

    CREATE TABLE aluno (
        id integer DEFAULT nextval('aluno_id_seq'::regclass) NOT NULL,
        nome character varying(255) NOT NULL
    );


    ALTER TABLE public.aluno OWNER TO edenc;

    --
    -- Name: aluno_materia; Type: TABLE; Schema: public; Owner: edenc; Tablespace:
    --

    CREATE TABLE aluno_materia (
        aluno_id integer NOT NULL,
        materia_id integer NOT NULL,
        nota integer
    );


    ALTER TABLE public.aluno_materia OWNER TO edenc;

    --
    -- Name: materia_id_seq; Type: SEQUENCE; Schema: public; Owner: edenc
    --

    CREATE SEQUENCE materia_id_seq
        INCREMENT BY 1
        NO MAXVALUE
        NO MINVALUE
        CACHE 1;


    ALTER TABLE public.materia_id_seq OWNER TO edenc;

    --
    -- Name: materia_id_seq; Type: SEQUENCE SET; Schema: public; Owner: edenc
    --

    SELECT pg_catalog.setval('materia_id_seq', 3, true);


    --
    -- Name: materia; Type: TABLE; Schema: public; Owner: edenc; Tablespace:
    --

    CREATE TABLE materia (
        id integer DEFAULT nextval('materia_id_seq'::regclass) NOT NULL,
        nome character varying(255) NOT NULL
    );


    ALTER TABLE public.materia OWNER TO edenc;

    --
    -- Name: turma_id; Type: SEQUENCE; Schema: public; Owner: edenc
    --

    CREATE SEQUENCE turma_id
        INCREMENT BY 1
        NO MAXVALUE
        NO MINVALUE
        CACHE 1;


    ALTER TABLE public.turma_id OWNER TO edenc;

    --
    -- Name: turma_id; Type: SEQUENCE SET; Schema: public; Owner: edenc
    --

    SELECT pg_catalog.setval('turma_id', 2, true);


    --
    -- Name: turma; Type: TABLE; Schema: public; Owner: edenc; Tablespace:
    --

    CREATE TABLE turma (
        id integer DEFAULT nextval('turma_id'::regclass) NOT NULL,
        turma character varying(255)
    );


    ALTER TABLE public.turma OWNER TO edenc;

    --
    -- Name: turma_aluno; Type: TABLE; Schema: public; Owner: edenc; Tablespace:
    --

    CREATE TABLE turma_aluno (
        turma_id integer NOT NULL,
        aluno_id integer NOT NULL
    );


    ALTER TABLE public.turma_aluno OWNER TO edenc;

    --
    -- Data for Name: aluno; Type: TABLE DATA; Schema: public; Owner: edenc
    --

    INSERT INTO aluno (id, nome) VALUES (1, 'JoÃ£o');
    INSERT INTO aluno (id, nome) VALUES (2, 'Maria');


    --
    -- Data for Name: aluno_materia; Type: TABLE DATA; Schema: public; Owner: edenc
    --

    INSERT INTO aluno_materia (aluno_id, materia_id, nota) VALUES (1, 1, NULL);
    INSERT INTO aluno_materia (aluno_id, materia_id, nota) VALUES (1, 2, NULL);
    INSERT INTO aluno_materia (aluno_id, materia_id, nota) VALUES (1, 3, NULL);
    INSERT INTO aluno_materia (aluno_id, materia_id, nota) VALUES (2, 1, NULL);


    --
    -- Data for Name: materia; Type: TABLE DATA; Schema: public; Owner: edenc
    --

    INSERT INTO materia (id, nome) VALUES (1, 'Biologia');
    INSERT INTO materia (id, nome) VALUES (2, 'MatemÃ¡tica');
    INSERT INTO materia (id, nome) VALUES (3, 'FÃ­sica');


    --
    -- Data for Name: turma; Type: TABLE DATA; Schema: public; Owner: edenc
    --

    INSERT INTO turma (id, turma) VALUES (1, '7Âª SÃ©rie');
    INSERT INTO turma (id, turma) VALUES (2, '6Âª SÃ©rie');


    --
    -- Data for Name: turma_aluno; Type: TABLE DATA; Schema: public; Owner: edenc
    --

    INSERT INTO turma_aluno (turma_id, aluno_id) VALUES (1, 1);
    INSERT INTO turma_aluno (turma_id, aluno_id) VALUES (2, 2);


    --
    -- Name: aluno_materia_pkey; Type: CONSTRAINT; Schema: public; Owner: edenc; Tablespace:
    --

    ALTER TABLE ONLY aluno_materia
        ADD CONSTRAINT aluno_materia_pkey PRIMARY KEY (aluno_id, materia_id);


    --
    -- Name: aluno_pkey; Type: CONSTRAINT; Schema: public; Owner: edenc; Tablespace:
    --

    ALTER TABLE ONLY aluno
        ADD CONSTRAINT aluno_pkey PRIMARY KEY (id);


    --
    -- Name: materia_pkey; Type: CONSTRAINT; Schema: public; Owner: edenc; Tablespace:
    --

    ALTER TABLE ONLY materia
        ADD CONSTRAINT materia_pkey PRIMARY KEY (id);


    --
    -- Name: turma_aluno_pkey; Type: CONSTRAINT; Schema: public; Owner: edenc; Tablespace:
    --

    ALTER TABLE ONLY turma_aluno
        ADD CONSTRAINT turma_aluno_pkey PRIMARY KEY (turma_id, aluno_id);


    --
    -- Name: turma_pkey; Type: CONSTRAINT; Schema: public; Owner: edenc; Tablespace:
    --

    ALTER TABLE ONLY turma
        ADD CONSTRAINT turma_pkey PRIMARY KEY (id);


    --
    -- Name: aluno_materia_aluno_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: edenc
    --

    ALTER TABLE ONLY aluno_materia
        ADD CONSTRAINT aluno_materia_aluno_id_fkey FOREIGN KEY (aluno_id) REFERENCES aluno(id);


    --
    -- Name: aluno_materia_materia_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: edenc
    --

    ALTER TABLE ONLY aluno_materia
        ADD CONSTRAINT aluno_materia_materia_id_fkey FOREIGN KEY (materia_id) REFERENCES materia(id);


    --
    -- Name: turma_aluno_aluno_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: edenc
    --

    ALTER TABLE ONLY turma_aluno
        ADD CONSTRAINT turma_aluno_aluno_id_fkey FOREIGN KEY (aluno_id) REFERENCES aluno(id);


    --
    -- Name: turma_aluno_turma_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: edenc
    --

    ALTER TABLE ONLY turma_aluno
        ADD CONSTRAINT turma_aluno_turma_id_fkey FOREIGN KEY (turma_id) REFERENCES turma(id);


    --
    -- Name: public; Type: ACL; Schema: -; Owner: postgres
    --

    REVOKE ALL ON SCHEMA public FROM PUBLIC;
    REVOKE ALL ON SCHEMA public FROM postgres;
    GRANT ALL ON SCHEMA public TO postgres;
    GRANT ALL ON SCHEMA public TO PUBLIC;


    --
    -- PostgreSQL database dump complete
    --

O seguinte comando shell Ã© o suficiente para iniciar:

    perl -MDBIx::Class::Schema::Loader=make_schema_at -le'make_schema_at("MySchema", { use_namespaces => 1, dump_directory => "./lib" }, 
    ["dbi:Pg:dbname=equinocio_students", "edenc", ""])'

A opÃ§Ã£o C<use_namespaces> indica que queremos prefixar nossas classes com
C<MySchema::Result::> e C<MySchema::ResultSet>, que Ã© a prÃ¡tica mais comum na
comunidade do C<DBIx::Class>.
A opÃ§Ã£o C<dump_directory> indica em qual diretÃ³rio queremos criar as classes.
O array C<["dbi:Pg:dbname=equinocio_students", "edenc", ""]> sÃ£o opÃ§Ãµes de
conexÃ£o com o banco de dados, tal qual seria passado ao C<DBI> (como vimos na
pequena implementaÃ§Ã£o de um DAO).
O diretÃ³rio C<lib> agora contÃ©m as classes com as definiÃ§Ãµes introspectadas da
base de dados.

Para obter mais opÃ§Ãµes de customizaÃ§Ã£o, consulte a documentaÃ§Ã£o do
C<DBIx::Class::Schema::Loader>.

=head4 Result Source

Objetos Result Source contÃ©m meta-dados sobre as tabelas, como o nome da
tabela, os nomes de colunas, restriÃ§Ãµes de unicidade e relacionamentos.
No arquivo C<lib/MySchema/Result/Aluno.pm> temos o cÃ³digo introspectado pelo
C<DBIx::Class::Schema::Loader> para a tabela aluno.

    __PACKAGE__->load_components("Core");

Essa instruÃ§Ã£o carrega a infra-estrutura bÃ¡sica do C<DBIx::Class>. Componentes
adicionais podem ser carregados aqui tambÃ©m.

    __PACKAGE__->table("aluno");

C<table> indica o nome da tabela que este Result Source estÃ¡ referenciando,
todas as consultas vÃ£o usar esse valor, literalmente.

    __PACKAGE__->add_columns(
      "id",
      {
        data_type => "integer",
        default_value => "nextval('aluno_id_seq'::regclass)",
        is_nullable => 0,
        size => 4,
      },
      "nome",
      {
        data_type => "character varying",
        default_value => undef,
        is_nullable => 0,
        size => 255,
      },
    );

C<add_columns> indica os nomes e tipos de dados das colunas da tabela. Apenas
o nome da coluna Ã© obrigatÃ³rio, as demais informaÃ§Ãµes nÃ£o sÃ£o necessÃ¡rias para
a operaÃ§Ã£o do C<DBIx::Class>.

    __PACKAGE__->set_primary_key("id");

C<set_primary_key> indica a chave primÃ¡ria desta tabela. A declaraÃ§Ã£o correta
da chave primÃ¡ria da tabela Ã© essencial para o bom funcionamento do
C<DBIx::Class>. Chaves compostas sÃ£o suportadas normalmente (A tabela
C<MySchema::Result::AlunoMateria> contÃ©m um exemplo).

    __PACKAGE__->add_unique_constraint("aluno_pkey", ["id"]);

C<add_unique_constraint> indica uma restriÃ§Ã£o de unicidade sobre uma tupla.
DeclaraÃ§Ãµes de unicidade facilitam a construÃ§Ã£o posterior de consultas.

    __PACKAGE__->has_many(
      "aluno_materias",
      "MySchema::Result::AlunoMateria",
      { "foreign.aluno_id" => "self.id" },
    );

C<has_many> indica um relacionamento 1-N, nesse caso, um registro em C<aluno>
pode ter vÃ¡rios registros relacionados na tabela C<aluno_materia>. As duas
tabelas se relacionam atravÃ©s da chave estrangeira C<aluno_id> na tabela
C<aluno_materia>, indicada pelo prefixo C<foreign>, e da chave primÃ¡ria C<id>,
na tabela C<aluno>, indicada pelo prefixo C<self>.
Outros tipos de relacionamento, como C<belongs_to> (N-1), C<has_one> (1-1) e
C<might_have> (1-1,0) sÃ£o utilizÃ¡veis baseados na mesma semÃ¢ntica.
Relacionamentos N-M sÃ£o um caso especial, Ã© necessÃ¡rio dois relacionamentos
(1-N) em duas tabelas distintas com uma terceira tabela (a
tabela-relacionamento). Por conta da natureza abstrata desse tipo de
relacionamento, o instrospectador nÃ£o consegue detectÃ¡-lo automaticamente.
A tabela C<AlunoMateria> Ã© um exemplo de tabela-relacionamento, o
C<DBIx::Class> jÃ¡ criou os relacionamentos bÃ¡sicos. Observe que os
relacionamentos tem como nome as chaves primÃ¡rias, atribuÃ­das automaticamente,
para evitar confusÃ£o com o valor da coluna, Ã© recomendÃ¡vel que se renomeie o
relacionamento:

    --- lib/MySchema/Result/AlunoMateria.pm
    +++ lib/MySchema/Result/AlunoMateria.pm
    @@ -18,11 +18,11 @@ __PACKAGE__->add_columns(
     __PACKAGE__->set_primary_key("aluno_id", "materia_id");
     __PACKAGE__->add_unique_constraint("aluno_materia_pkey", ["aluno_id", "materia_id"]);
     __PACKAGE__->belongs_to(
    -  "materia_id",
    +  "materia",
       "MySchema::Result::Materia",
       { id => "materia_id" },
     );
    -__PACKAGE__->belongs_to("aluno_id", "MySchema::Result::Aluno", { id => "aluno_id" });
    +__PACKAGE__->belongs_to("aluno", "MySchema::Result::Aluno", { id => "aluno_id" });


     # Created by DBIx::Class::Schema::Loader v0.04006 @ 2010-03-09 21:13:41


Falta unir as tabelas relevantes atravÃ©s da tabela-relacionamento.

Aluno:

    --- lib/MySchema/Result/Aluno.pm
    +++ lib/MySchema/Result/Aluno.pm
    @@ -40,7 +40,7 @@ __PACKAGE__->has_many(
     # Created by DBIx::Class::Schema::Loader v0.04006 @ 2010-03-09 21:13:41
     # DO NOT MODIFY THIS OR ANYTHING ABOVE! md5sum:6dR0OXCT5EZN62DTK5cKWw

    -
    +__PACKAGE__->many_to_many(materias => aluno_materias => 'materia');

     # You can replace this text with custom content, and it will be preserved on regeneration
     1;

Materia:

    --- lib/MySchema/Result/Materia.pm
    +++ lib/MySchema/Result/Materia.pm
    @@ -35,7 +35,7 @@ __PACKAGE__->has_many(
     # Created by DBIx::Class::Schema::Loader v0.04006 @ 2010-03-09 21:13:41
     # DO NOT MODIFY THIS OR ANYTHING ABOVE! md5sum:FnsLZ7hmxCmJyjYguAtRdg

    -
    +__PACKAGE__->many_to_many(alunos => aluno_materias => 'aluno');

     # You can replace this text with custom content, and it will be preserved on regeneration
     1;

O primeiro argumento de C<many_to_many> indica o nome do relacionamento. O
segundo argumento indica um relacionamento C<has_many> na tabela atual para a
tabela-relacionamento. O terceiro argumento indica o relacionamento
C<belongs_to> na tabela-relacionamento que serÃ¡ utilizado para chegar na segunda
tabela relacionada.

Um script de teste:

    diff --git a/source/script/test.pl b/source/script/test.pl
    new file mode 100644
    index 0000000..04b1243
    --- /dev/null
    +++ b/source/script/test.pl
    @@ -0,0 +1,9 @@
    +use warnings;
    +use strict;
    +use MySchema;
    +
    +my $schema = MySchema->connect('dbi:Pg:dbname=equinocio_students', 'edenc', '');
    +my $estudantes = $schema->resultset('Aluno');
    +foreach my $estudante ($estudantes->all) {
    +   print ref $estudante, ' => ', $estudante->nome, "\n";
    +}

Para executar:

    perl -Ilib script/test.pl

O resultado:

    MySchema::Result::Aluno => JoÃ£o
    MySchema::Result::Aluno => Maria

Percebe-se que o C<DBIx::Class> realizou a consulta e populou os objetos
adequados.

Consultando matÃ©rias:

    diff --git a/source/script/test.pl b/source/script/test.pl
    index 07e3395..faed9f7 100644
    --- a/source/script/test.pl
    +++ b/source/script/test.pl
    @@ -6,4 +6,7 @@ my $schema = MySchema->connect('dbi:Pg:dbname=equinocio_students', 'edenc', '');
     my $estudantes = $schema->resultset('Aluno');
     foreach my $estudante ($estudantes->all) {
        print ref $estudante, ' => ', $estudante->nome, "\n";
    +   foreach my $materia ($estudante->materias->all) {
    +       print "\t", ref $materia, ' => ', $materia->nome, "\n";
    +   }
     }

    MySchema::Result::Aluno => JoÃ£o
            MySchema::Result::Materia => Biologia
            MySchema::Result::Materia => MatemÃ¡tica
            MySchema::Result::Materia => FÃ­sica
    MySchema::Result::Aluno => Maria
            MySchema::Result::Materia => Biologia

Observe que o mÃ©todo C<materias> estÃ¡ disponÃ­vel por conta da declaraÃ§Ã£o
C<many_to_many> em Aluno.
Para melhorar a conveniÃªncia de acesso entre turmas e alunos, Ã© necessÃ¡ria a
inclusÃ£o de outro relacionamento C<many_to_many> entre C<aluno> e C<turma>
atravÃ©s da tabela-relacionamento C<aluno_turma>. Um detalhe importante Ã© que o
introspectador utiliza inflexÃ£o automÃ¡tica em inglÃªs para determinar o nome dos
relacionamentos, como o exemplo estÃ¡ em portuguÃªs, alguns reparos sÃ£o
necessÃ¡rios:

    diff --git a/source/lib/MySchema/Result/Turma.pm b/source/lib/MySchema/Result/Turma.pm
    index b6edf19..20c28bf 100644
    --- a/source/lib/MySchema/Result/Turma.pm
    +++ b/source/lib/MySchema/Result/Turma.pm
    @@ -26,7 +26,7 @@ __PACKAGE__->add_columns(
     __PACKAGE__->set_primary_key("id");
     __PACKAGE__->add_unique_constraint("turma_pkey", ["id"]);
     __PACKAGE__->has_many(
    -  "turma_alunoes",
    +  "turma_alunos",
       "MySchema::Result::TurmaAluno",
       { "foreign.turma_id" => "self.id" },
     );

    diff --git a/source/lib/MySchema/Result/Aluno.pm b/source/lib/MySchema/Result/Aluno.pm
    index 3444c57..0163c8e 100644
    --- a/source/lib/MySchema/Result/Aluno.pm
    +++ b/source/lib/MySchema/Result/Aluno.pm
    @@ -31,7 +31,7 @@ __PACKAGE__->has_many(
       { "foreign.aluno_id" => "self.id" },
     );
     __PACKAGE__->has_many(
    -  "turma_alunoes",
    +  "turma_alunos",
       "MySchema::Result::TurmaAluno",
       { "foreign.aluno_id" => "self.id" },
     );

    diff --git a/source/lib/MySchema/Result/TurmaAluno.pm b/source/lib/MySchema/Result/TurmaAluno.pm
    index 74cad38..b24509f 100644
    --- a/source/lib/MySchema/Result/TurmaAluno.pm
    +++ b/source/lib/MySchema/Result/TurmaAluno.pm
    @@ -15,8 +15,8 @@ __PACKAGE__->add_columns(
     );
     __PACKAGE__->set_primary_key("turma_id", "aluno_id");
     __PACKAGE__->add_unique_constraint("turma_aluno_pkey", ["turma_id", "aluno_id"]);
    -__PACKAGE__->belongs_to("turma_id", "MySchema::Result::Turma", { id => "turma_id" });
    -__PACKAGE__->belongs_to("aluno_id", "MySchema::Result::Aluno", { id => "aluno_id" });
    +__PACKAGE__->belongs_to("turma", "MySchema::Result::Turma", { id => "turma_id" });
    +__PACKAGE__->belongs_to("aluno", "MySchema::Result::Aluno", { id => "aluno_id" });


     # Created by DBIx::Class::Schema::Loader v0.04006 @ 2010-03-09 21:13:41

Por fim, a declaraÃ§Ã£o do relacionamento C<many_to_many>:

    diff --git a/source/lib/MySchema/Result/Aluno.pm b/source/lib/MySchema/Result/Aluno.pm
    index 0163c8e..4353455 100644
    --- a/source/lib/MySchema/Result/Aluno.pm
    +++ b/source/lib/MySchema/Result/Aluno.pm
    @@ -41,6 +41,7 @@ __PACKAGE__->has_many(
     # DO NOT MODIFY THIS OR ANYTHING ABOVE! md5sum:6dR0OXCT5EZN62DTK5cKWw

     __PACKAGE__->many_to_many(materias => aluno_materias => 'materia');
    +__PACKAGE__->many_to_many(turmas => turma_alunos => 'aluno');

     # You can replace this text with custom content, and it will be preserved on regeneration
     1;
    diff --git a/source/lib/MySchema/Result/Turma.pm b/source/lib/MySchema/Result/Turma.pm
    index 20c28bf..4ccd20a 100644
    --- a/source/lib/MySchema/Result/Turma.pm
    +++ b/source/lib/MySchema/Result/Turma.pm
    @@ -35,7 +35,7 @@ __PACKAGE__->has_many(
     # Created by DBIx::Class::Schema::Loader v0.04006 @ 2010-03-09 21:13:41
     # DO NOT MODIFY THIS OR ANYTHING ABOVE! md5sum:yruj1LRVJruSL2miqJFQlA

    -
    +__PACKAGE__->many_to_many(alunos => turma_alunos => 'aluno');

     # You can replace this text with custom content, and it will be preserved on regeneration
     1;

    diff --git a/source/script/test.pl b/source/script/test.pl
    index 8152c51..695b2f8 100644
    --- a/source/script/test.pl
    +++ b/source/script/test.pl
    @@ -3,12 +3,13 @@ use strict;
     use MySchema;

     my $schema = MySchema->connect('dbi:Pg:dbname=equinocio_students', 'edenc', '');
    -my $estudantes = $schema->resultset('Aluno');
    -foreach my $estudante ($estudantes->all) {
    -   print ref $estudante, ' => ', $estudante->nome, "\n";
    -   foreach my $aluno_materia ($estudante->aluno_materias->all) {
    -       my $materia = $aluno_materia->materia;
    -       print "\t", ref $materia, ' => ', $materia->nome, "\n";
    -       print "\t\t", ref $aluno_materia, ' => ', $aluno_materia->nota, "\n";
    +my $turmas = $schema->resultset('Turma');
    +foreach my $turma ($turmas->all) {
    +   print ref $turma, ' => ', $turma->turma, "\n";
    +   foreach my $aluno ($turma->alunos->all) {
    +       print "\t", ref $aluno, ' => ', $aluno->nome, "\n";
    +       foreach my $materia ($aluno->materias) {
    +           print "\t\t", ref $materia, ' => ', $materia->nome, "\n";
    +       }
        }
     }

    perl -Ilib script/test.pl

    MySchema::Result::Turma => 7Âª SÃ©rie
            MySchema::Result::Aluno => JoÃ£o
                    MySchema::Result::Materia => Biologia
                    MySchema::Result::Materia => MatemÃ¡tica
                    MySchema::Result::Materia => FÃ­sica
    MySchema::Result::Turma => 6Âª SÃ©rie
            MySchema::Result::Aluno => Maria
                    MySchema::Result::Materia => Biologia


=head4 Por trÃ¡s das cenas

O C<DBIx::Class> funciona de uma maneira bastante similar ao que implementamos
na classe C<DAO>. As seguintes etapas ocorrem durante uma consulta:

=over

=item DefiniÃ§Ã£o de Consultas

Estabelecimento dos critÃ©rios para recuperaÃ§Ã£o dos dados atravÃ©s de SQL ou do
mecanismo de geraÃ§Ã£o de SQL embutido. No exemplo, nÃ£o houveram critÃ©rios
explÃ­citos, porÃ©m o C<DBIx::Class> utilizou os meta-dados nos result sources
para induzir critÃ©rios implicitamente.

    my $turmas = $schema->resultset('Turma');

Indica que todos os registros da tabela C<turma> devem ser recuperados. O valor
que passamos como argumento Ã© o nome do result source, que reside na classe
C<MySchema::Result::Turma>. NÃ£o Ã© necessÃ¡rio indicar o nome completo da classe.

    $turma->alunos;

Indica que todos os registros relacionados Ã quele objeto especÃ­fico devem ser
recuperados. O C<DBIx::Class> utiliza os meta-dados fornecidos na definiÃ§Ã£o do
relacionamento para construir o join com um critÃ©rio adequado e recuperar os
dados na tabela correta. Uma forma equivalente de se obter o mesmo conjunto de
registros seria construir o critÃ©rio manualmente:

    $schema->resultset('TurmaAluno')
        ->search({ turma_id => $turma->id })
        ->related_resultset('aluno');

O critÃ©rio Ã© bastante parecido com o que estÃ¡ definido no relacionamento.
PorÃ©m, utilizar a definiÃ§Ã£o do relacionamento Ã© mais eficiente do ponto de
vista de engenharia porque mantÃ©m o critÃ©rio canonizado em um Ãºnico lugar,
facilitando o processo de manutenÃ§Ã£o.
Os detalhes de funcionamento dos mÃ©todos C<search> e C<related_resultset> serÃ£o
abordados mais adiante junto com a definiÃ§Ã£o do conceito de Result Set.

=item PreparaÃ§Ã£o e ExecuÃ§Ã£o

O C<DBIx::Class> tenta otimizar o processo de consultas o mÃ¡ximo possÃ­vel. As
consultas sÃ£o realizadas de maneira "preguiÃ§osa", isso significa que sÃ³ haverÃ¡
execuÃ§Ã£o quando os dados forem realmente necessÃ¡rios e nÃ£o durante o processo
de definiÃ§Ã£o da consulta. Por exemplo, a consulta que recupera a lista de
turmas nÃ£o acontece durante a chamada a C<$schema->resultset('Turma')>, mas
durante a chamada a C<$turmas->all>. Isso Ã© um conceito fundamental, porque
talvez fosse necessÃ¡rio o acrÃ©scimo de critÃ©rios extras antes da realizaÃ§Ã£o da
consulta.
Uma outra otimizaÃ§Ã£o que ocorre na recuperaÃ§Ã£o dos dados Ã© o caching automÃ¡tico
dos resultados. A consulta sÃ³ ocorre na primeira vez em que acontece a chamada
C<$turmas->all>, uma segunda invocaÃ§Ã£o irÃ¡ utilizar os dados cacheados. O mesmo
vale para os objetos C<$turma> individuais, nÃ£o acontecem consultas adicionais
a cada vez que se invoca C<$turma->turma>, por exemplo.
Os handles de consultas do C<DBI> tambÃ©m sÃ£o cacheados, portanto hÃ¡ um pequeno
ganho de desempenho em relaÃ§Ã£o Ã  implementaÃ§Ã£o do DAO, que prepara um novo
handle, mesmo sendo uma repetiÃ§Ã£o da mesma consulta. AlÃ©m do cache, ocorre uma
verificaÃ§Ã£o da conexÃ£o com o banco, se houver uma falha na comunicaÃ§Ã£o, o
C<DBIx::Class> irÃ¡ automaticamente tentar re-estabelecer a conexÃ£o antes de
executar a consulta.

=item Colapso de Dados

Os dados recuperados por uma consulta sÃ£o sempre fornecidos pelo backend de
forma tabular, o que requer um trabalho de re-estruturaÃ§Ã£o durante a populaÃ§Ã£o
dos objetos. Por exemplo, a consulta para recuperar todos os alunos e suas
respectivas matÃ©rias seria:

       SELECT aluno.id,
              aluno.nome,
              aluno_materias.aluno_id,
              aluno_materias.materia_id,
              aluno_materias.nota,
              materia.id,
              materia.nome
         FROM turma_aluno me
         JOIN aluno aluno ON aluno.id = me.aluno_id
    LEFT JOIN aluno_materia aluno_materias ON aluno_materias.aluno_id = aluno.id
    LEFT JOIN materia materia ON materia.id = aluno_materias.materia_id

E o resultado seria:

     id | nome  | aluno_id | materia_id | nota | id |    nome
    ----+-------+----------+------------+------+----+------------
      1 | JoÃ£o  |        1 |          1 |      |  1 | Biologia
      1 | JoÃ£o  |        1 |          2 |      |  2 | MatemÃ¡tica
      1 | JoÃ£o  |        1 |          3 |      |  3 | FÃ­sica
      2 | Maria |        2 |          1 |      |  1 | Biologia

Existem 3 registros contendo os dados de um Ãºnico registro em aluno, devido ao
produto cartesiano resultante do join. Ã desejÃ¡vel que apenas um objeto aluno
equivalente ao registro C<JoÃ£o> exista na aplicaÃ§Ã£o para esse caso. O que
permite exibir a hierarquia dos dados sem repetiÃ§Ãµes como acontece no exemplo.
Baseado nos meta-dados presentes nas classes Result Source, o C<DBIx::Class>
consegue re-estruturar os dados tabulares mapeando-os para objetos
estruturados. Esse processo se chama "colapso de dados", devido ao processo
de destruiÃ§Ã£o de dados duplicados que acontece por trÃ¡s das cenas.

=item InflaÃ§Ã£o de Dados

O processo de "inflar" dados ocorre quando dados passam do backend para a
aplicaÃ§Ã£o, o sentido inverso se chama "deflaÃ§Ã£o". Na implementaÃ§Ã£o exemplar
da classe DAO, a inflaÃ§Ã£o foi feita manualmente. O C<DBIx::Class> fornece um
mecanismo de inflaÃ§Ã£o extensÃ­vel que, por padrÃ£o, constrÃ³i objetos da mesma
classe que o Result Source, como por exemplo C<MySchema::Result::Aluno>. Esses
objetos herdam da classe C<DBIx::Class::Row> que fornece operaÃ§Ãµes sobre dados
de um Ãºnico registro. O processo de inflaÃ§Ã£o pode ser alterado atravÃ©s da
sobrecarga do mÃ©todo C<inflate_result> em qualquer classe Result Source. Por
exemplo, se fosse desejÃ¡vel construir hashes invÃ©s de objetos
C<MySchema::Result::Materia>:

    diff --git a/source/lib/MySchema/Result/Materia.pm b/source/lib/MySchema/Result/Materia.pm
    index c6ce5d8..401a1bd 100644
    --- a/source/lib/MySchema/Result/Materia.pm
    +++ b/source/lib/MySchema/Result/Materia.pm
    @@ -37,6 +37,11 @@ __PACKAGE__->has_many(

     __PACKAGE__->many_to_many(alunos => aluno_materias => 'aluno');

    +sub inflate_result {
    +    my($self, $source, $data) = @_;
    +    return $data;
    +}
    +
     # You can replace this text with custom content, and it will be preserved on regeneration
     1;

    diff --git a/source/script/test.pl b/source/script/test.pl
    index 695b2f8..377fffe 100644
    --- a/source/script/test.pl
    +++ b/source/script/test.pl
    @@ -1,6 +1,7 @@
     use warnings;
     use strict;
     use MySchema;
    +use Data::Dump;

     my $schema = MySchema->connect('dbi:Pg:dbname=equinocio_students', 'edenc', '');
     my $turmas = $schema->resultset('Turma');
    @@ -9,7 +10,7 @@ foreach my $turma ($turmas->all) {
        foreach my $aluno ($turma->alunos->all) {
            print "\t", ref $aluno, ' => ', $aluno->nome, "\n";
            foreach my $materia ($aluno->materias) {
    -           print "\t\t", ref $materia, ' => ', $materia->nome, "\n";
    +           print "\t\t", ref $materia, ' => ', Data::Dump::dump($materia), "\n";
            }
        }
     }

JSON invÃ©s de hash:

    diff --git a/source/lib/MySchema/Result/Materia.pm b/source/lib/MySchema/Result/Materia.pm
    index 401a1bd..982d538 100644
    --- a/source/lib/MySchema/Result/Materia.pm
    +++ b/source/lib/MySchema/Result/Materia.pm
    @@ -2,6 +2,7 @@ package MySchema::Result::Materia;

     use strict;
     use warnings;
    +use JSON ();

     use base 'DBIx::Class';

    @@ -39,7 +40,7 @@ __PACKAGE__->many_to_many(alunos => aluno_materias => 'aluno');

     sub inflate_result {
         my($self, $source, $data) = @_;
    -    return $data;
    +    return JSON::to_json($data);
     }

     # You can replace this text with custom content, and it will be preserved on regeneration
    diff --git a/source/script/test.pl b/source/script/test.pl
    index 377fffe..45590cb 100644
    --- a/source/script/test.pl
    +++ b/source/script/test.pl
    @@ -10,7 +10,7 @@ foreach my $turma ($turmas->all) {
        foreach my $aluno ($turma->alunos->all) {
            print "\t", ref $aluno, ' => ', $aluno->nome, "\n";
            foreach my $materia ($aluno->materias) {
    -           print "\t\t", ref $materia, ' => ', Data::Dump::dump($materia), "\n";
    +           print "\t\t", ref $materia, ' => ', $materia, "\n";
            }
        }
     }

=back

=head4 Objetos Result Set

AtÃ© agora, foram abordados exemplos bÃ¡sicos de consultas e recuperaÃ§Ã£o de
dados. PorÃ©m, efetuar consultas de forma manutenÃ­vel e reaproveitÃ¡vel nÃ£o Ã© uma
tarefa fÃ¡cil. Suponha a seguinte lista de requisitos e o SQL equivalente:

=over

=item * Enumerar Todos os Alunos

    SELECT * FROM aluno;

=item * Enumerar Alunos de Uma Turma

    SELECT * FROM aluno me
      JOIN turma_aluno ta
        ON ta.aluno_id = me.id
     WHERE ta.turma_id = ?;

=item * Enumerar Alunos Cursando uma Determinada MatÃ©ria

    SELECT * FROM aluno me
      JOIN aluno_materia ma
        ON ma.aluno_id = me.id
     WHERE ma.materia_id = ?;

=back

Uma outra forma de enxergar um requisito desses Ã© atravÃ©s de conjuntos:

=begin pod:xhtml

<p align="center"><img src="http://sao-paulo.pm.org/static/images/equinocio/2010/mar/dbic/Sets.png" alt="Sets" /></p>

=end pod:xhtml

Em C<DBIx::Class> nÃ³s expressamos esses conjuntos atravÃ©s de objetos Result Set:

    my $alunos = $schema->resultset('Aluno');

C<$alunos> contÃ©m o conjunto universo dos registros de alunos, ou seja, todos
os alunos.

    my $alunos_turma1 = $alunos->search(
        { 'turma_alunos.turma_id' => 1 },
        { join => [qw(turma_alunos)] }
    );

C<$alunos_turma1> Ã© um subconjunto de C<$alunos>, que contÃ©m registros dos
alunos da turma 1. Como a informaÃ§Ã£o de relacionamento entre turmas estÃ¡ na
tabela-relacionamento C<turma_aluno>, Ã© necessÃ¡ria a declaraÃ§Ã£o de um join com
o relacionamento equivalente.
Para maior conveniÃªncia de abstraÃ§Ã£o, podem ser criados mÃ©todos no Result Set equivalente:

    diff --git a/source/lib/MySchema/ResultSet/Aluno.pm b/source/lib/MySchema/ResultSet/Aluno.pm
    new file mode 100644
    index 0000000..0163cbf
    --- /dev/null
    +++ b/source/lib/MySchema/ResultSet/Aluno.pm
    @@ -0,0 +1,23 @@
    +package MySchema::ResultSet::Aluno;
    +use warnings;
    +use strict;
    +
    +use base 'DBIx::Class::ResultSet';
    +
    +sub turma {
    +    my($self, $turma_id) = @_;
    +    return $self->search(
    +        { 'turma_alunos.turma_id' => $turma_id },
    +        { join => [qw(turma_alunos)] }
    +    );
    +}
    +
    +sub materia {
    +    my($self, $materia_id) = @_;
    +    return $self->search(
    +        { 'aluno_materias.materia_id' => $materia_id },
    +        { join => [qw(aluno_materias)] }
    +    );
    +}
    +
    +1;

O mÃ©todo C<search> Ã© um construtor de objetos Result Set, cada invocaÃ§Ã£o desse
mÃ©todo cria um clone do conjunto original e acrescenta os parÃ¢metros passados.
O primeiro argumento, Ã© uma referÃªcia para um hash especificando o critÃ©rio de
seleÃ§Ã£o de registros, caso anterior, deseja-se utilizar um critÃ©rio sobre uma
tabela relacionada, nesse caso, se utiliza o nome do relacionamento, a exemplo
de C<aluno_materias.materia_id>. O segundo hash, sÃ£o atributos passados para o
Result Set, nesse caso, indicando o join desejado.

    diff --git a/source/script/test.pl b/source/script/test.pl
    index 377fffe..3e21ffa 100644
    --- a/source/script/test.pl
    +++ b/source/script/test.pl
    @@ -4,13 +4,7 @@ use MySchema;
     use Data::Dump;

     my $schema = MySchema->connect('dbi:Pg:dbname=equinocio_students', 'edenc', '');
    -my $turmas = $schema->resultset('Turma');
    -foreach my $turma ($turmas->all) {
    -   print ref $turma, ' => ', $turma->turma, "\n";
    -   foreach my $aluno ($turma->alunos->all) {
    -       print "\t", ref $aluno, ' => ', $aluno->nome, "\n";
    -       foreach my $materia ($aluno->materias) {
    -           print "\t\t", ref $materia, ' => ', Data::Dump::dump($materia), "\n";
    -       }
    -   }
    +my $alunos = $schema->resultset('Aluno')->turma(1);
    +foreach my $aluno ($alunos->all) {
    +   print "\t", ref $aluno, ' => ', $aluno->nome, "\n";
     }

Mais detalhes sobre o mÃ©todo C<search> podem ser encontrados na documentaÃ§Ã£o da
classe C<DBIx::Class::ResultSet>.

Eventualmente surgirÃ£o formas desejÃ¡veis de se combinar os resultados
anteriores, por exemplo, enumerar alunos cursando uma determinada matÃ©ria em
uma turma.

    SELECT * FROM aluno me
      JOIN turma_aluno ta ON ta.aluno_id = me.id
      JOIN aluno_materia ma
        ON ma.aluno_id = me.id
     WHERE ta.turma_id = ?
       AND ma.materia_id = ?;

Como cada invocaÃ§Ã£o de C<search> retorna um novo subconjunto, pode-se encadear
invocaÃ§Ãµes para combinar os critÃ©rios das chamadas.

    diff --git a/source/script/test.pl b/source/script/test.pl
    index 3e21ffa..68df674 100644
    --- a/source/script/test.pl
    +++ b/source/script/test.pl
    @@ -4,7 +4,7 @@ use MySchema;
     use Data::Dump;

     my $schema = MySchema->connect('dbi:Pg:dbname=equinocio_students', 'edenc', '');
    -my $alunos = $schema->resultset('Aluno')->turma(1);
    +my $alunos = $schema->resultset('Aluno')->turma(1)->materia(2);
     foreach my $aluno ($alunos->all) {
        print "\t", ref $aluno, ' => ', $aluno->nome, "\n";
     }

NÃ£o Ã© necessÃ¡ria a escrita de SQL ou consultas adicionais, apenas foram
reaproveitados mÃ©todos que jÃ¡ existiam antes e que puderam ser combinados pela
arquitetura de consultas do C<DBIx::Class>. Pelo fato das consultas serem
preguiÃ§osas, a consulta nÃ£o ocorre durante a invocaÃ§Ã£o de C<turma> ou
C<materia>, apenas quando se invoca C<all>, e nesse ponto, os critÃ©rios da
consulta foram populados pelos mÃ©todos anteriores.
O fato de que cada invocaÃ§Ã£o de C<search> constrÃ³i um novo conjunto permite o
reaproveitamento dos objetos result set. Por exemplo:

    my $alunos_turma1 = $schema->resultset('Alunos')->turma(1);
    my $alunos_turma1_aprovados = $alunos_turma1->search(
        { 'materia_alunos.nota' => { '>' => 7 } },
        { join => [qw(materia_alunos)] }
    );
    my $alunos_turma1_materia1 = $alunos_turma1->materia(1);
    my $alunos_turma1_materia1_aprovados->materia(1);

=head2 ConclusÃ£o

Observando a forma como as aplicaÃ§Ãµes interagem com bases de dados, fica Ã³bvio
que o principal problema de se escrever uma camada intermediÃ¡ria Ã© alcanÃ§ar um
contrato flexÃ­vel, tanto com a aplicaÃ§Ã£o quanto com a base de dados. O
C<DBIx::Class> tenta se destacar dos outros ORMs atravÃ©s do fornecimento de
uma arquitetura formal porÃ©m flexÃ­vel, e que tem opÃ§Ãµes de extensibilidade
convenientes. O C<DBIx::Class> se propÃµe muito mais a ser um framework de
construÃ§Ã£o de camadas de acesso a dados do que um ORM propriamente dito.
Hoje abordamos alguns princÃ­pios fundamentais sobre camadas de acesso a dados
baseadas em C<DBIx::Class>, assim como algumas funcionalidades bÃ¡sicas de
arquitetura e construÃ§Ã£o de consultas. AmanhÃ£ serÃ£o abordadas formas avanÃ§adas
de consulta e escrita, alÃ©m de tÃ©cnicas de desenvolvimento e depuraÃ§Ã£o.

=head2 AUTOR

Eden Cardim C<< <edencardim@gmail.com> >> Ã© consultor de perl independente hÃ¡ 4 anos, trabalha com perl desde 1998 e Ã© contribuidor dos projetos C<DBIx::Class>, C<Catalyst> e C<Reaction>, alÃ©m de contribuidor do CPAN. Atualmente, presta serviÃ§o para a ShadowCat System Ltd.

=cut


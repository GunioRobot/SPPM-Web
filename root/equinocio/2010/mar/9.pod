=pod

=head1 AutenticaE<ccedil>E<atilde>o em aplicaE<ccedil>E<otilde>es usando Catalyst

O objetivo da autenticaE<ccedil>E<atilde>o E<eacute> estabelecer ou confirmar
a identidade de um usuE<aacute>rio, o qual pode ser uma pessoa ou grupo de
pessoas que usem as mesmas credenciais, provendo desta forma, suporte as
demais partes do sistema como controle de acesso (autorizaE<ccedil>E<atilde>o)
e customizaE<ccedil>E<atilde>o da interface com o usuE<aacute>rio. Neste
artigo, veremos como realizar autenticaE<ccedil>E<atilde>o bE<aacute>sica em
aplicaE<ccedil>E<otilde>es que usam o web I<framework> Catalyst com o
I<plugin> padrE<atilde>o, porE<eacute>m nE<atilde>o se E<eacute> obrigado a
usar este I<plugin>, o Catalyst E<eacute> flexE<iacute>vel suficiente para
realizar a autenticaE<ccedil>E<atilde>o e autorizaE<ccedil>E<atilde>o da forma
que se quer implementar.

=head2 Requisitos

Para realizar a autenticaE<ccedil>E<atilde>o, precisa-se de um conjunto de
I<plugins> sendo eles:

=over 4

=item * L<Catalyst::Plugin::Authentication>

Este I<plugin> provE<ecirc> a estrutura bE<aacute>sica para
aplicaE<ccedil>E<otilde>es com Catalyst realizarem
autenticaE<ccedil>E<atilde>o e autorizaE<ccedil>E<atilde>o, contendo
tambE<eacute>m alguns I<plugins> de C<Credential> e C<Store>.

=item * Um I<plugin> de C<Credential>

=item * Um I<plugin> de C<Store>

=item * I<Plugins> para controle de sessE<atilde>o

A fim de permitir que teus usuE<aacute>rios permaneE<ccedil>am conectados
E<agrave> sua aplicaE<ccedil>E<atilde>o atravE<eacute>s das pE<aacute>ginas,
E<eacute> preciso guardar este estado de alguma forma tanto do lado do
servidor quanto no cliente. Pode-se usar o recomendado pelo Catalyst para tal
fim, L<Catalyst::Plugin::Session>, juntamente com um I<plugin> de C<State> e
outro de C<Store>.

=back

Antes de prosseguir, lembre-se de carregar os I<plugins> requeridos na classe
da aplicaE<ccedil>E<atilde>o.

    use Catalyst qw/
        Authentication
        Session
        Session::Store::Foo
        Session::State::Bar
    /;

=head2 Catalyst::Plugin::Authentication

A autenticaE<ccedil>E<atilde>o no Catalyst estE<aacute> projetada para ser bem
flexE<iacute>vel aos vE<aacute>rios tipos de processos que se podem realizar,
basicamente dividida em mE<oacute>dulos de armazenamento (C<Store>) e de
verificaE<ccedil>E<atilde>o (C<Credential>). O C<Credential> E<eacute>
responsE<aacute>vel por verificar a identidade do usuE<aacute>rio, geralmente
comparando a informaE<ccedil>E<atilde>o provida por este com a
informaE<ccedil>E<atilde>o encontrada no C<Store>.

Estes mE<oacute>dulos sE<atilde>o carregados em conjunto por meio de
I<realms>, permitindo assim E<agrave> aplicaE<ccedil>E<atilde>o ter
mE<uacute>ltiplos mE<eacute>todos de autenticaE<ccedil>E<atilde>o de
usuE<aacute>rios. Toda aplicaE<ccedil>E<atilde>o que realize
autenticaE<ccedil>E<atilde>o deve ter ao menos um C<realm> que E<eacute> o
C<default>, mas pode-se ter quantos forem necessE<aacute>rios.

=head2 ConfiguraE<ccedil>E<atilde>o

Os itens da configuraE<ccedil>E<atilde>o vE<atilde>o depender dos
mE<oacute>dulos de C<Credential> e C<Store> que se tenha decidido usar. A
seguir, temos um exemplo de configuraE<ccedil>E<atilde>o (no formato do
L<Config::General>) que utiliza dois mE<eacute>todos de
autenticaE<ccedil>E<atilde>o com o padrE<atilde>o para o C<realm> de
C<password>. Consulte a documentaE<ccedil>E<atilde>o para detalhes sobre a
configuraE<ccedil>E<atilde>o de cada tipo de C<Credential> e C<Store>, bem
como a do L<Catalyst::Plugin::Authentication>.

    <authentication>
        default_realm password
        <password>
            <credential>
                class Password
                password_field passwd
                password_type crypted
            </credential>
            <store>
                class DBIx::Class
                user_class DB::LocalAccount
            </store>
        </password>
        <signature>
            <credential>
                class Signature
                signature_field sign
                session_field session_data
            </credential>
            <store>
                class DBIx::Class
                user_class DB::LocalAccount
            </store>
        </signature>
    </authentication>

AtE<eacute> a versE<atilde>o 0.10008 do I<plugin> de
autenticaE<ccedil>E<atilde>o, vocE<ecirc> precisaria colocar toda os I<realms>
dentro da chave C<realms>.

    <authentication>
        default_realm password
        <realms>
            <password>

            (...)

            </password>
            <signature>

            (...)

            </signature>
        </realms>
    </authentication>

=head2 ImplementaE<ccedil>E<atilde>o

Existem apenas trE<ecirc>s partes que se referem a
implementaE<ccedil>E<atilde>o bE<aacute>sica de autenticaE<ccedil>E<atilde>o.

=over 3

=item * I<Login>

=item * Verificar que um usuE<aacute>rio estE<aacute> "logado"

=item * I<Logout>

=back

=head3 I<Login>

Esta parte envolve - geralmente a partir de um formulE<aacute>rio - obter as
credenciais do usuE<aacute>rio e verificar que este E<eacute> valido. Pode-se
usar um processador de formulE<aacute>rios como o L<HTML::FormHandler>, mas
nE<atilde>o E<eacute> requisito. Para fazer I<login> do usuE<aacute>rio,
usa-se o mE<eacute>todo C<authenticate> a partir de uma I<action> num
I<controller>.

    sub login : Action {
        my ( $self, $c ) = @_;
        my $params = $c->req->body_params;
        if ( $params->{'username'} && $params->{'password'} ) {
            if ( $c->authenticate({ map { $_ => $params->{$_} } qw/username password/ }) ) {
                # usuario valido e autenticado
                # redirecione para algum caminho da sua aplicacao
            } else {
                # mostrar a pagina com o formulario de autenticacao e uma mensagem de erro
            }
        } else {
            # mostrar a pagina com o formulario de autenticacao
        }
    }

=head3 Verificar que um usuE<aacute>rio estE<aacute> "logado"

Em determinados caminhos da aplicaE<ccedil>E<atilde>o, E<eacute>
necessE<aacute>rio que se tenha um usuE<aacute>rio "logado", como por exemplo
uma pE<aacute>gina de preferE<ecirc>ncias ou se a aplicaE<ccedil>E<atilde>o
utiliza dados deste para gerar e mostrar informaE<ccedil>E<otilde>es numa
pE<aacute>gina. Deste modo, faz-se necessE<aacute>rio retornar para o passo de
I<login> caso a verificaE<ccedil>E<atilde>o falhe. Para tal fim, pode-se usar
alguns mE<eacute>todos como

=over 3

=item * C<user_exists>

Retorna verdeiro se um usuE<aacute>rio estE<aacute> "logado". Se esta for a
E<uacute>nica informaE<ccedil>E<atilde>o necessE<aacute>ria, nE<atilde>o
interessando qual usuE<aacute>rio especificamente E<eacute>, a depender do
mecanismo de armazenamento, este mE<eacute>todo pode ser muito mais eficiente.
A diferenE<ccedil>a entre este mE<eacute>todo e o C<user> E<eacute> que este
retornarE<aacute> verdadeiro, mesmo se o usuE<aacute>rio "logado" nE<atilde>o
foi ainda recuperado a partir do armazenamento.

=item * C<user_in_realm>

Semelhante ao C<user_exists>, exceto que apenas retorna verdadeiro se o
usuE<aacute>rio estE<aacute> "logado" -e- foi recuperado a partir do C<realm>
fornecido.

=item * C<user>

Retorna o atual usuE<aacute>rio "logado", ou C<undef> se nE<atilde>o
hE<aacute> algum.

=back

Como por exemplo

    sub requires_user : Action {
        my ( $self, $c ) = @_;
        if ( $c->user_exists ) {
            # usuE<aacute>rio "logado"
        } else {
            # retorna ao passo de login
        }
    }

=head3 I<Logout>

E por E<uacute>ltimo a mais simples, resume-se a apenas chamar o
mE<eacute>todo C<logout> e redirecionar o usuE<aacute>rio para o caminho de
I<login> ou algum outro.

    sub logout : Action {
        my ( $self, $c ) = @_;
        $c->logout;
        # redirecione
    }

=head2 Veja tambE<eacute>m

L<Catalyst Advent Calendar
2008-19|http://www.catalystframework.org/calendar/2008/19>,
L<CatalystX::SimpleLogin> e L<Humane Login
Screens|http://www.shadowcat.co.uk/blog/matt-s-trout/humane-login-screens/>.

=head2 Autor

wreis: Wallace Reis <wallace@reis.org.br>

